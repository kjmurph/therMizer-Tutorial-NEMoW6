---
title: "Simplified FishMIP Hawaii Region therMizer ModelRuns"
author: "Phoebe Woodworth-Jefcoats & Kieran Murphy"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: rmdformats::readthedown
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## Model runs

This script runs the two simulations: one with (histsoc) and one without (nat) fishing.

Set up the environment:
```{r}
# Load libraries
library("remotes")
remotes::install_github("sizespectrum/therMizer")
library("therMizer")
```

Set up the species parameters:
```{r}
# Load parameters 
HIparams <- read.csv("HIregion_species_params.csv", header = TRUE)
HIinter <- read.csv("HIregion_inter.csv", row.names = 1)
HIinter <- as(HIinter,"matrix")
HIgears <- read.csv("HIregion_gears_params.csv", header = TRUE)

# Generate parameters
params <- newMultispeciesParams(HIparams, interaction = HIinter, kappa = 1e12, min_w_pp = 1e-14, w_pp_cutoff = 455400) 
```

Set up time steps:
```{r}
time_steps <- seq(0,600,1)

# I ran into trouble using any time steps that didn't start with 0.
# I also had trouble using fractional time steps.  
# So, what's here as year is really a month.  
# Suggestions for a better solution welcome
```

Set up the resource:
```{r}
# Load resource spectra 
# Note: You may need to update this path
isimip_plankton <- read.table("GFDL_resource_spectra_60arcmin.dat")
isimip_plankton <- as(isimip_plankton, "matrix")
sizes <- names(params@initial_n_pp)
n_pp_array <- array(NA, dim = c(length(time_steps), length(sizes)), dimnames = list(time = time_steps, w = sizes))

# Fill array
# Need an extra time step preceding the simulation
n_pp_array[1,] <- isimip_plankton[1,]
for (t in seq(1,length(time_steps) - 1,1)) {
  n_pp_array[t + 1,] <- isimip_plankton[t,]
}
```

# Need to update initial npp for the params object to align with a sensible metric from the isimip plankton

```{r}
params_updated_initial_n_pp <- params

# params@resource_params$w_pp_cutoff # Find largest size class for background resource
# 455400

# initialNResource(params_updated_initial_n_pp)[which(w_full(params_updated_initial_n_pp) < 455400)]<- 10^(n_pp_array[1,])[which(w_full(params_updated_initial_n_pp) < 455400)]/params_updated_initial_n_pp@dw_full # normalise the plankton spectrum to match the therMizer

initialNResource(params_updated_initial_n_pp)[which(w_full(params_updated_initial_n_pp) < 455400)]<- 10^n_pp_array[1,][which(w_full(params_updated_initial_n_pp) < 455400)]

#need to cut resource at 455400g
initialNResource(params_updated_initial_n_pp)[which(w_full(params_updated_initial_n_pp) >=resource_params(params_updated_initial_n_pp)$w_pp_cutoff)]<-0.0 # sets all above 455400g to 0


head(initialNResource(params))
head(initialNResource(params_updated_initial_n_pp))
```



## Dummy temperature example

If you were using the temperature forcing we prepared in `Preparing_Forcings_Hawaiian_Longline.Rmd`

```{r}
# tos <- readRDS("Temperature_Forcings/tos.rds")
# t500m <- readRDS("Temperature_Forcings/t500m.rds")
# t1000m <- readRDS("Temperature_Forcings/t1000m.rds")
# t1500m <- readRDS("Temperature_Forcings/t1500m.rds")
# tob <- readRDS("Temperature_Forcings/tob.rds")
# 
# ocean_temp <- abind::abind(tos,t500m,t1000m, t1500m, tob, along = 2)
# 
# realm_names <- c("tos","t500m","t1000m", "t1500m", "tob")
# 
# colnames(ocean_temp) <- realm_names
# rownames(ocean_temp) <- time_steps
```



Set up temperature-related information:
```{r}
# Load ocean temp array
# Note: You may need to update this path
ocean_temp <- read.table("therMizer-FishMIP-2022-HI/GFDL_ocean_temp_realm_array.dat")
ocean_temp <- as(ocean_temp, "matrix")
r <- colnames(ocean_temp)
ocean_temp_array <- array(NA, dim = c(length(time_steps), length(r)), dimnames = list(time = time_steps, realm_names = r))
ocean_temp_array[1,] <- ocean_temp[1,]
for (t in seq(1,length(time_steps) - 1, 1)) {
  ocean_temp_array[t + 1,] <- ocean_temp[t,]
}

# Load vertical migration and exposure
load("HIregion_vertical_migration_array.Rdata") # Note: this is named vertical_migration_array

HIexposure <- read.table("HIregion_exposure_array.dat")
HIexposure <- as(HIexposure, "matrix")
```

Set up the needed fishing selectivity function:
```{r}
# We need to define our double knife-edge selectivity function to match that 
# used in Woodworth-Jefcoats et al. 2019
double_knife_edge <- function(w, knife_edge_size1, knife_edge_size2, ...) { 
	sel <- rep(0, length(w)) 
	
	# Phased in linearly
	F0 <- which(w < knife_edge_size1) # to find one size smaller than that fished, for the 0 value 
	F1 <- which(w < knife_edge_size2) # to find end of escalation size range 
	lo_sel <- max(F0):max(F1) 
	sel[lo_sel] <- seq(0, 1, length = length(lo_sel)) # linear increase from 0 to F 
	sel[w >= knife_edge_size2] <- 1 
	return(sel) 
} 
```

Add gear parameters:
```{r}
names(HIgears) <- c("species", "gear", "sel_func", "knife_edge_size1", "knife_edge_size2", "catchability" )
gear_params(params) <- HIgears
```

Load effort:
```{r}
# Load effort
# Note: You may need to update this path
isimip_effort <- read.csv("therMizer-FishMIP-2022-HI/HI_Monthly_Fishing_Mortality.csv")
isimip_effort <- as(isimip_effort, "matrix")
gear_name = c("Longline")
effort_array <- array(NA, c(length(time_steps), length(gear_name)), dimnames = list(time = time_steps, gear = gear_name))
effort_array[1,] = isimip_effort[1,2]
for (t in seq(1,length(time_steps) - 1, 1)) {
  effort_array[t + 1] <- isimip_effort[t,2]
}
```

Add temperature and resource information to the parameters:
```{r}
paramsT <- upgradeTherParams(params_updated_initial_n_pp, ocean_temp_array = ocean_temp_array,
                            n_pp_array = n_pp_array, 
                            vertical_migration_array = vertical_migration_array,
                            exposure_array = HIexposure, 
                            aerobic_effect = TRUE, metabolism_effect = TRUE)

# Nice test to see that things are working correctly
plotTherPerformance(params)
```

Project to steady-state, with and without fishing:
```{r}
# Project to steady
params_steady_F <- projectToSteady(paramsT, t_max = 600, dt = 1/12, tol = 1e-7, effort = effort_array[1]) 
sim_steady_F <- projectToSteady(paramsT, t_max = 600, dt = 1/12, tol = 1e-7, effort = effort_array[1], return_sim = TRUE) 
params_steady_noF <- projectToSteady(paramsT, t_max = 600, dt = 1/12, tol = 1e-7, effort = 0) 
sim_steady_noF <- projectToSteady(paramsT, t_max = 600, dt = 1/12, tol = 1e-7, effort = 0, return_sim = TRUE) 

# Include a validation run with F = 0.2 (the estimated F for most of the species modeled, per stock assessments)
params_steady_validate <- projectToSteady(paramsT, t_max = 600, dt = 1/12, tol = 1e-7, effort = 0.2) 
sim_steady_validate <- projectToSteady(paramsT, t_max = 600, dt = 1/12, tol = 1e-7, effort = 0.2, return_sim = TRUE) 

# Test to see how things look
plot(sim_steady_F)
plot(sim_steady_noF)
plot(sim_steady_validate)
```

Run simulations:
```{r}
# And do a simulation using the steady parameters
projection_steady_F <- project(params_steady_F, dt = 1/12, t_max = 600, t_save = 1/12, effort = effort_array)
projection_steady_noF <- project(params_steady_noF, dt = 1/12, t_max = 600, t_save = 1/12, effort = 0)

# Test to see how things look
plot(projection_steady_F)
plot(projection_steady_noF)
```

Save output:
```{r}
# Save projections for investigating results and formatting for ISIMIP
save(sim_steady_validate, file = "sim_steady_validate.Rdata")
save(projection_steady_F, file = "projection_steady_F.Rdata")
save(projection_steady_noF, file = "projection_steady_noF.Rdata")
```

